# VCampus 模块开发指南

## 概述

本指南以**登录模块**为例，详细介绍 VCampus 项目的模块开发流程。登录模块是一个完整的端到端功能，涵盖了客户端、服务端、公共模块的协作开发，其他模块的开发也可以采取这种流程。

## 项目架构

```
vcampus/
├── vcampus-client/          # 客户端模块 (JavaFX)
├── vcampus-server/          # 服务端模块 (Socket Server)
├── vcampus-common/          # 公共模块 (DTO, 枚举, 工具类)
└── vcampus-database/        # 数据库模块 (SQL脚本)
```

## 主函数分析

### 客户端主函数 (MainApp.java)

一定要注意instance和globalSocket的静态设置，这有利于整个客户端只有一个MainApp和socket

**应用启动流程：**

```java
// MainApp.java - JavaFX应用主类
public class MainApp extends Application {
    private static SocketClient globalSocketClient;
  
    @Override
    public void start(Stage primaryStage) {
        try {
            // 1. 初始化全局网络连接
            initializeGlobalNetworkConnection();
          
            // 2. 加载登录界面
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/LoginView.fxml"));
            Parent root = loader.load();
          
            // 3. 设置场景和窗口
            Scene scene = new Scene(root);
            primaryStage.setTitle("VCampus 登录系统");
            primaryStage.setScene(scene);
            primaryStage.show();
          
        } catch (Exception e) {
            System.err.println("应用启动失败: " + e.getMessage());
        }
    }
  
    /**
     * 初始化全局网络连接
     * 在应用启动时创建SocketClient并连接到服务端
     */
    private void initializeGlobalNetworkConnection() {
        try {
            globalSocketClient = new SocketClient();
            boolean connected = globalSocketClient.connect();
            if (!connected) {
                System.err.println("无法连接到服务端，请检查服务端是否启动");
            }
        } catch (Exception e) {
            System.err.println("初始化全局网络连接失败: " + e.getMessage());
        }
    }
  
    /**
     * 获取全局SocketClient实例
     * 供所有服务层使用，确保网络连接复用
     */
    public static SocketClient getGlobalSocketClient() {
        return globalSocketClient;
    }
  
    public static void main(String[] args) {
        launch(args);
    }
}
```

**关键点说明：**

1. **全局连接管理**：

   - 在 `start()` 方法中首先调用 `initializeGlobalNetworkConnection()`
   - 创建全局 `SocketClient` 实例，供整个应用使用
   - 确保网络连接在UI加载前就建立完成
2. **连接状态检查**：

   - 检查连接是否成功建立
   - 如果连接失败，给出明确的错误提示
   - 应用仍会启动，但网络功能可能不可用
3. **资源加载顺序**：

   ```
   应用启动 → 初始化网络连接 → 加载FXML界面 → 显示窗口
   ```

### 服务端主函数 (MainServer.java)

**服务端启动流程：**

```java
// MainServer.java - Socket服务端主类
public class MainServer {
    private static final int DEFAULT_PORT = 9090;
    private static final int MAX_CLIENTS = 100;
  
    public static void main(String[] args) {
        try {
            // 1. 创建SocketServer实例
            SocketServer server = new SocketServer(DEFAULT_PORT, MAX_CLIENTS);
          
            // 2. 启动服务器
            System.out.println("VCampus 服务端启动中...");
            System.out.println("监听端口: " + DEFAULT_PORT);
          
            server.start();
          
            // 3. 等待客户端连接
            System.out.println("服务端已启动，等待客户端连接...");
          
            // 4. 保持服务端运行
            while (true) {
                Thread.sleep(1000);
            }
          
        } catch (Exception e) {
            System.err.println("服务端启动失败: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

### 启动顺序说明

**正确的启动顺序：**

1. **先启动服务端**：

   ```bash
   cd vcampus-serve
   mvn exec:java
   ```
2. **再启动客户端**：

   ```bash
   cd vcampus-client
   mvn javafx:run
   ```

**启动检查要点：**

- 确保服务端端口（9090）未被占用
- 检查防火墙设置，允许端口通信
- 查看控制台输出，确认启动状态

## 模块开发流程

### 1. 需求分析

**登录模块需求：**

- 用户输入用户名和密码进行登录
- 支持忘记密码功能
- 客户端基础验证
- 服务端业务验证
- 网络通信错误处理
- 用户友好的界面反馈

### 2. 设计阶段

#### 2.1 数据模型设计 (vcampus-common)

**User.java - 用户数据传输对象，每个模块都有特定的数据传输对象，比如图书馆肯定要传输book类，首先应该确定下来的就是这些客户端和服务端公用的东西。**

```java
public class User implements Serializable {
    private String userId;      // 7位数字用户ID
    private String password;    // 密码（明文传输）
  
    // 构造方法和getter/setter
}
```

**Message.java - 网络通信消息，这里不用重复创建，只是提醒一下好好看message有哪些参数和方法，一定要注意方法**

```java
public class Message implements Serializable {
    private ActionType action;   // 操作类型枚举
    private Object data;         // 传递的数据
    private boolean status;      // 操作状态
    private String message;      // 状态描述

}
```

#### 2.2 枚举定义 (vcampus-common)

**ActionType.java - 操作类型枚举，补充你要的枚举类型。**

```java
public enum ActionType {
    LOGIN,              // 登录
    FORGET_PASSWORD,    // 忘记密码
    // 其他操作类型...
}
```

**Role.java - 用户角色枚举，这里提醒一嘴，以后管理员要增加，第二周先开发学生端。**

```java
public enum Role {
    STUDENT("学生"),
    TEACHER("教师"),
    ADMIN("管理员");
  
    private final String desc;
}
```

### 3. 开发阶段（我按照消息传递的路径开发，感觉更直观一些）

#### 3.1 客户端开发 (vcampus-client)

**步骤1：创建UI界面 (LoginView.fxml)，这里其实知道ui有啥就行，设计是主要的,注意id和对应的动作。**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.control.*?>

<VBox fx:controller="com.vcampus.client.controller.LoginController">
    <TextField fx:id="usernameField" promptText="请输入用户名"/>
    <PasswordField fx:id="passwordField" promptText="请输入密码"/>
    <Button fx:id="loginButton" text="登录"/>
    <Label fx:id="statusLabel" text="请输入用户名和密码"/>
    <Hyperlink fx:id="forgotPasswordLink" text="忘记密码？"/>
</VBox>
```

**步骤2：创建控制器层 (LoginController.java)，客户端控制器的作用类似JavaScript，需要响应ui界面的动作，比如点击登录按钮会执行handleLogin，这里我以执行handleLogin为例进行开发，你们开发可以并行。**

```java
public class LoginController implements IClientController {
    @FXML private TextField usernameField;
    @FXML private PasswordField passwordField;
    @FXML private Button loginButton;
  
    private final LoginService loginService = new LoginService();
  
    /**
     * 初始化方法，在FXML加载完成后自动调用
     */
    @FXML
    private void initialize() {
        // 为登录按钮添加点击事件
        loginButton.setOnAction(event -> handleLogin());
      
        // 为输入框添加回车键事件
        usernameField.setOnAction(event -> handleLogin());
        passwordField.setOnAction(event -> handleLogin());
      
        // 将自己注册到MessageController（关键步骤）
        registerToMessageController();
    }
  
    /**
     * 处理登录按钮点击事件
     */
    private void handleLogin() {
        // 1. 获取用户输入
        // 2. 客户端验证
        // 3. 调用服务层
        // 4. 处理响应
    }
  
    /**
     * 注册到MessageController（关键步骤）
     */
    @Override
    public void registerToMessageController() {
        // 获取全局SocketClient中的MessageController
        com.vcampus.client.controller.MessageController messageController = 
            loginService.getGlobalSocketClient().getMessageController();
        if (messageController != null) {
            messageController.setLoginController(this);
        }
    }
  
    /**
     * 处理登录响应（从MessageController调用）
     * @param message 登录响应消息
     */
    public void handleLoginResponse(Message message) {
        // 在JavaFX应用线程中更新UI
        Platform.runLater(() -> {
            handleLoginResult(message);
        });
    }
}
```

**尤其需要注意集成 `IClientController`接口**

```java
public interface IClientController {
  
    /**
     * 注册到MessageController
     * 每个客户端控制器都需要实现此方法，将自己注册到MessageController中
     */
    void registerToMessageController();
}
```

**步骤3：创建服务层 (LoginService.java)，控制器只是控制，内部不含有处理信息的逻辑，处理信息需要在服务层执行，这里注意socket是要通过MainApp来接入的，保证整个客户端都用一个socket**

```java
public class LoginService {
    private final SocketClient socketClient;
  
    /**
     * 构造函数，获取全局SocketClient实例
     * 通过MainApp.getGlobalSocketClient()获取全局网络连接
     */
    public LoginService() {
        this.socketClient = MainApp.getGlobalSocketClient();
    }
  
    /**
     * 执行登录（同步模式）
     * @param username 用户名
     * @param password 密码
     * @return 登录结果消息
     */
    public Message login(String username, String password) {
        // 创建用户对象
        User loginUser = new User(username, password);
      
        // 创建登录消息
        Message loginMessage = new Message(ActionType.LOGIN, loginUser);
      
        // 发送登录请求，响应会由SocketClient中的MessageController自动处理
        Message response = socketClient.sendMessage(loginMessage);
      
        return response;
    }
  
    /**
     * 获取全局Socket客户端（供控制器使用）
     * @return SocketClient实例
     */
    public SocketClient getGlobalSocketClient() {
        return socketClient;
    }
}
```

**关键点说明：**

1. **注册机制（最重要）**：

   - 在 `initialize()` 方法中调用 `registerToMessageController()`
   - 确保控制器在UI加载完成后立即注册到MessageController
   - 只有注册后才能接收服务端的响应消息
2. **全局SocketClient获取**：

   - 通过 `MainApp.getGlobalSocketClient()` 获取全局网络连接实例
   - 这个实例在应用启动时就已经创建并连接
3. **网络连接流程**：这个已经封装好了

   ```
   MainApp启动 → 创建SocketClient → 连接到服务端 → 启动接收线程 → 供各服务层使用
   ```
4. **消息发送机制**：

   - `socketClient.sendMessage()` 发送消息到服务端
   - 服务端响应通过异步接收线程自动处理
   - 响应消息通过 `MessageController` 路由到对应的控制器方法
5. **连接状态检查**：

   - 每次发送前检查 `socketClient.isConnected()`
   - 确保网络连接正常才发送消息

#### 3.2 服务端开发 (vcampus-server)

**步骤1：注册到MessageController，这里初始化控制器和在switch语句里加入内容即可**

```java
// MessageController.java - 服务端消息路由中心
public class MessageController {
    private final UserController userController;
  
    public MessageController() {
        // 在构造函数中创建并注册所有控制器
        this.userController = new UserController();
        // 如果有其他控制器，在这里添加：
        // this.bookController = new BookController();
        // this.libraryController = new LibraryController();
    }
  
    /**
     * 处理客户端消息
     * @param request 客户端请求消息
     * @return 服务端响应消息
     */
    public Message handleMessage(Message request) {
        try {
            // 验证消息格式
            if (request == null || request.getAction() == null) {
                return Message.failure(ActionType.LOGIN, "无效的消息格式");
            }
          
            // 根据ActionType路由到对应的控制器
            switch (request.getAction()) {
                case LOGIN:
                    return userController.handleLogin(request);
                case FORGET_PASSWORD:
                    return userController.handleForgetPassword(request);
                // 添加新的操作类型时，在这里添加对应的case
                // case BORROW_BOOK:
                //     return bookController.handleBorrowBook(request);
                default:
                    return Message.failure(request.getAction(), "不支持的操作类型: " + request.getAction());
            }
        } catch (Exception e) {
            System.err.println("处理消息时发生错误: " + e.getMessage());
            return Message.failure(request.getAction(), "服务器内部错误");
        }
    }
}
```

**步骤2：创建控制器层 (UserController.java)，这里的handle方法一定要注意返回的类型是message，也就是服务端对于请求的回应，回应会自动回复回去，已经封装好了**

```java
public class UserController {
    private final UserService userService;
  
    public UserController() {
        // 创建数据访问层实现（数据库负责人提供）
        IUserDao userDao = new UserDaoImpl();
        // 注入到服务层
        this.userService = new UserService(userDao);
    }
  
    /**
     * 处理登录请求
     * @param message 登录请求消息
     * @return 登录响应消息
     */
    public Message handleLogin(Message message) {
        try {
            // 1. 提取用户数据
            User loginUser = (User) message.getData();
          
            // 2. 调用服务层
            UserService.LoginResult result = userService.validateLogin(loginUser);
          
            // 3. 构造响应消息
            if (result.isSuccess()) {
                return Message.success(ActionType.LOGIN, result.getUser(), result.getMessage());
            } else {
                return Message.failure(ActionType.LOGIN, result.getMessage());
            }
        } catch (Exception e) {
            System.err.println("处理登录请求时发生错误: " + e.getMessage());
            return Message.failure(ActionType.LOGIN, "服务器内部错误");
        }
    }
    
    /**
     * 处理忘记密码请求
     * @param message 忘记密码请求消息
     * @return 忘记密码响应消息
     */
    public Message handleForgetPassword(Message message) {
        try {
            // 1. 提取用户数据
            User user = (User) message.getData();
            
            // 2. 调用服务层
            UserService.ForgetPasswordResult result = userService.handleForgetPassword(
                user.getUserId(), user.getPassword());
            
            // 3. 构造响应消息
            if (result.isSuccess()) {
                return Message.success(ActionType.FORGET_PASSWORD, null, result.getMessage());
            } else {
                return Message.failure(ActionType.FORGET_PASSWORD, result.getMessage());
            }
        } catch (Exception e) {
            System.err.println("处理忘记密码请求时发生错误: " + e.getMessage());
            return Message.failure(ActionType.FORGET_PASSWORD, "服务器内部错误");
        }
    }
}
```

**步骤2.5：定义数据访问接口 (IUserDao.java)**

在创建服务层之前，需要先定义**数据访问接口**，这样数据库负责人就知道需要实现什么样的接口,这个接口在公共模块的dao文件夹里面设置.

```java
// IUserDao.java - 用户数据访问接口
public interface IUserDao {
    /**
     * 根据用户名和密码验证用户登录
     * @param username 用户名
     * @param password 密码
     * @return 用户信息，如果验证失败返回null
     */
    User validateLogin(String username, String password);
    
    /**
     * 根据用户名查找用户
     * @param username 用户名
     * @return 用户信息，如果不存在返回null
     */
    User findByUsername(String username);
    
    /**
     * 更新用户密码
     * @param username 用户名
     * @param newPassword 新密码
     * @return 更新是否成功
     */
    boolean updatePassword(String username, String newPassword);
    
    /**
     * 提交密码重置申请
     * @param username 用户名
     * @param newPassword 新密码
     * @return 申请是否提交成功
     */
    boolean submitPasswordResetRequest(String username, String newPassword);
    
    /**
     * 检查用户名是否存在
     * @param username 用户名
     * @return 用户是否存在
     */
    boolean existsByUsername(String username);
}
```

**接口设计说明：**

1. **职责分离**：接口只定义数据访问方法，不包含业务逻辑
2. **方法命名**：使用动词开头，清晰表达操作意图
3. **返回值设计**：
   - 查询方法返回实体对象或null
   - 更新方法返回boolean表示操作结果
4. **参数设计**：使用基本类型和实体对象，避免复杂参数
5. **异常处理**：接口不声明异常，由实现类处理

**数据库负责人需要实现：**

- 创建 `UserDaoImpl` 类实现 `IUserDao` 接口
- 实现所有接口方法的具体数据库操作
- 处理数据库连接、SQL执行、异常处理等底层细节
- 确保数据访问的安全性和性能

**步骤3：创建服务层 (UserService.java)**

```java
public class UserService {
    private final IUserDao userDao;
    
    /**
     * 构造函数，注入数据访问层
     * @param userDao 用户数据访问接口
     */
    public UserService(IUserDao userDao) {
        this.userDao = userDao;
    }
    
    // 后面的内容省略,可以查看源码
}
```

**注册机制说明：**

1. **自动注册**：在 `MessageController` 构造函数中自动创建所有控制器实例
2. **消息路由**：根据 `ActionType` 枚举值自动路由到对应的控制器方法
3. **扩展性**：添加新功能时，只需：
   - 在 `ActionType` 中添加新的枚举值
   - 创建对应的控制器类
   - 在 `MessageController` 构造函数中创建控制器实例
   - 在 `handleMessage()` 方法中添加对应的 case 分支

**开发要点：**

- **依赖注入**：控制器通过构造函数注入服务层，服务层注入数据访问层
- **分层架构**：控制器 → 服务层 → 数据访问层，职责清晰分离
- **接口设计**：数据访问层使用接口，便于测试和替换实现
- **异常处理**：每层都要处理异常，避免异常向上传播
- **返回结果封装**：使用内部类封装返回结果，提供统一的结果格式
- **控制器注册机制确保消息正确路由**

**依赖关系图：**

```
UserController (控制器层)
    ↓ 依赖注入
UserService (服务层)
    ↓ 依赖注入  
IUserDao (数据访问接口)
    ↓ 实现
UserDaoImpl (数据访问实现)
```

### 4. 客户端响应处理机制

#### 4.1 响应消息接收流程

**异步接收线程处理：这个已经封装好了，不用管**

```java
// SocketClient.java 中的异步接收线程
private void receiveLoop() {
    while (running && isConnected()) {
        try {
            Object obj = in.readObject();
            if (obj instanceof Message) {
                Message message = (Message) obj;
                // 将接收到的响应消息路由到MessageController
                messageController.handleMessage(message);
            }
        } catch (Exception e) {
            System.err.println("接收消息异常: " + e.getMessage());
            break;
        }
    }
}
```

**客户端MessageController路由：一定要注意声明与set方法，set方法是注册的关键之一**

```java
// 客户端 MessageController.java - 响应消息路由中心
public class MessageController {
    private LoginController loginController;
    /**
     * 设置LoginController实例（由UI层调用）
     * @param controller LoginController实例
     */
    public void setLoginController(LoginController controller) {
        this.loginController = controller;
    }
  
    public void handleMessage(Message message) {
        switch (message.getAction()) {
            case LOGIN:
                    // 调用LoginController的响应处理方法
                    loginController.handleLoginResponse(message);
                break;
            default:
                System.err.println("未知的消息类型: " + message.getAction());
        }
    }
}
```

#### 4.2 控制器响应处理方法

**LoginController响应处理：Platform.runLater()要注意，这玩意表明是在一个ui里**

```java
public class LoginController implements IClientController {
    // ... 其他代码 ...
  
    /**
     * 处理登录响应（从MessageController调用）
     * @param message 登录响应消息
     */
    public void handleLoginResponse(Message message) {
        // 在JavaFX应用线程中更新UI
        Platform.runLater(() -> {
            handleLoginResult(message);
        });
    }
  
    /**
     * 处理登录结果
     * @param message 登录响应消息
     */
    private void handleLoginResult(Message message) {
        if (message.isStatus()) {
            // 登录成功
            User user = (User) message.getData();
            statusLabel.setText("登录成功，欢迎 " + user.getUserId());
            // 跳转到主界面或执行其他成功操作
            navigateToMainInterface(user);
        } else {
            // 登录失败
            statusLabel.setText("登录失败: " + message.getMessage());
            showError("登录失败", message.getMessage());
        }
    }
}
```

#### 4.3 服务器响应处理方法

复杂处理交给server，登录逻辑没有复杂的处理，所以这里略去。

### 5. 网络通信层（可读，我已经封装好了，仔细阅读上面的内容即可）

#### 5.1 网络通信架构

**全局SocketClient管理机制：**

```java
// MainApp.java - 应用启动时创建全局连接
public class MainApp extends Application {
    private static SocketClient globalSocketClient;
  
    private void initializeGlobalNetworkConnection() {
        try {
            globalSocketClient = new SocketClient();
            globalSocketClient.connect(); // 连接到服务端
        } catch (Exception e) {
            System.err.println("初始化全局网络连接失败: " + e.getMessage());
        }
    }
  
    public static SocketClient getGlobalSocketClient() {
        return globalSocketClient;
    }
}
```

**SocketClient核心功能：**

```java
// SocketClient.java - 网络通信核心类
public class SocketClient implements IMessageClientSrv {
    private Socket socket;
    private ObjectOutputStream out;
    private ObjectInputStream in;
    private MessageController messageController;
    private Thread receiveThread; // 异步接收线程
  
    @Override
    public Message sendMessage(Message message) {
        if (!isConnected()) {
            return Message.failure(message.getAction(), "网络连接未建立");
        }
      
        try {
            out.writeObject(message); // 发送消息
            out.flush();
            return Message.success(message.getAction(), "消息已发送");
        } catch (Exception e) {
            disconnect();
            return Message.failure(message.getAction(), "发送失败");
        }
    }
  
    // 异步接收线程，自动处理服务端响应
    private void receiveLoop() {
        while (running && isConnected()) {
            try {
                Object obj = in.readObject();
                if (obj instanceof Message) {
                    Message message = (Message) obj;
                    messageController.handleMessage(message); // 路由到对应控制器
                }
            } catch (Exception e) {
                // 处理接收异常
            }
        }
    }
}
```

**消息路由机制：**

```java
// MessageController.java - 消息路由中心
public class MessageController {
    private LoginController loginController;
  
    public void handleMessage(Message message) {
        switch (message.getAction()) {
            case LOGIN:
                if (loginController != null) {
                    loginController.handleLoginResponse(message);
                }
                break;
            case FORGET_PASSWORD:
                if (loginController != null) {
                    loginController.handleForgetPasswordResponse(message);
                }
                break;
            // 其他消息类型...
        }
    }
}
```

**服务端MessageController架构：**

```java
// 服务端 MessageController.java - 服务端消息路由中心
public class MessageController {
    private final UserController userController;
    // 未来可以添加更多控制器
    // private final BookController bookController;
    // private final LibraryController libraryController;
  
    public MessageController() {
        // 在构造函数中注册所有控制器
        this.userController = new UserController();
        // this.bookController = new BookController();
        // this.libraryController = new LibraryController();
    }
  
    public Message handleMessage(Message request) {
        try {
            if (request == null || request.getAction() == null) {
                return Message.failure(ActionType.LOGIN, "无效的消息格式");
            }
          
            // 根据ActionType路由到对应的控制器
            switch (request.getAction()) {
                case LOGIN:
                    return userController.handleLogin(request);
                case FORGET_PASSWORD:
                    return userController.handleForgetPassword(request);
                // 添加新功能时的扩展点
                // case BORROW_BOOK:
                //     return bookController.handleBorrowBook(request);
                default:
                    return Message.failure(request.getAction(), "不支持的操作类型");
            }
        } catch (Exception e) {
            return Message.failure(request.getAction(), "服务器内部错误");
        }
    }
}
```

**服务端消息处理流程：**

```java
// SocketServer.java 中的消息处理
private void handleClient(Socket clientSocket) {
    // ... 连接建立代码 ...
  
    while (isRunning && !clientSocket.isClosed()) {
        try {
            // 1. 接收客户端消息
            Message request = (Message) in.readObject();
          
            // 2. 交给工作线程池处理
            workerPool.submit(() -> {
                try {
                    // 3. 通过MessageController路由消息
                    Message response = messageController.handleMessage(request);
                  
                    // 4. 发送响应给客户端
                    synchronized (out) {
                        out.writeObject(response);
                        out.flush();
                    }
                } catch (IOException e) {
                    System.err.println("发送响应失败: " + e.getMessage());
                }
            });
        } catch (Exception e) {
            // 处理异常
        }
    }
}
```

#### 5.2 消息处理机制

**完整的消息传递流程：**

1. **客户端UI加载** → `LoginController.initialize()` 注册到MessageController
2. **客户端UI交互** → `LoginController.handleLogin()` 获取用户输入
3. **客户端验证** → `LoginService.validateInputFormat()` 进行基础验证
4. **客户端发送请求** → `LoginService.login()` 创建消息并发送
5. **网络传输** → `SocketClient` 将消息发送到服务端
6. **服务端接收** → `SocketServer` 接收客户端消息
7. **服务端路由** → 根据 `ActionType` 路由到 `UserController`
8. **服务端处理** → `UserController.handleLogin()` 调用业务逻辑
9. **服务端响应** → `UserService.validateLogin()` 处理业务并返回结果
10. **网络返回** → 响应消息通过网络返回给客户端
11. **客户端接收** → `MessageController` 接收响应并调用对应处理方法
12. **客户端更新UI** → `LoginController.handleLoginResponse()` 更新界面

**关键点：步骤1的注册必须在步骤4发送消息之前完成，否则无法接收响应！**

#### 5.3 网络连接配置

**连接参数配置：**

```java
// SocketClient.java 中的连接配置
public class SocketClient implements IMessageClientSrv {
    private static final String DEFAULT_HOST = "localhost";
    private static final int DEFAULT_PORT = 9090;
    private static final int CONNECTION_TIMEOUT = 5000; // 5秒连接超时
    private static final int READ_TIMEOUT = 10000; // 10秒读取超时
  
    @Override
    public boolean connect() {
        try {
            socket = new Socket();
            socket.connect(new java.net.InetSocketAddress(host, port), CONNECTION_TIMEOUT);
            socket.setSoTimeout(READ_TIMEOUT);
          
            out = new ObjectOutputStream(socket.getOutputStream());
            in = new ObjectInputStream(socket.getInputStream());
          
            startReceiveThread(); // 启动异步接收线程
            return true;
        } catch (Exception e) {
            System.err.println("连接服务端失败: " + e.getMessage());
            return false;
        }
    }
}
```

**连接状态管理：**

```java
// 检查连接状态的方法
public boolean isConnected() {
    return socket != null && socket.isConnected() && !socket.isClosed();
}

// 获取连接信息
public String getConnectionInfo() {
    if (isConnected()) {
        return String.format("已连接到 %s:%d", host, port);
    } else {
        return "未连接";
    }
}
```

#### 5.4 错误处理

**客户端错误处理：**

```java
private void showError(String message) {
    Alert alert = new Alert(AlertType.ERROR);
    alert.setTitle("错误");
    alert.setHeaderText("输入错误");
    alert.setContentText(message);
    alert.showAndWait();
}
```

**服务端错误处理：**

```java
try {
    // 业务逻辑处理
} catch (Exception e) {
    System.err.println("处理登录请求时发生错误: " + e.getMessage());
    return Message.failure(ActionType.LOGIN, "服务器内部错误");
}
```

**编写人：** 谌宣羽
**更新时间：** 2025年9月
**版本：** 1.0
